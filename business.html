<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Business Methods and Processes</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@300&display=swap" rel="stylesheet">
  </head>
    <body>
      <div class="wrapper">
        <header>
          <h1>Business Methods and Processes</h1>
        </header>

        <main>    
          <section class="openingSection">
          </section>

          <section>
            <h2>Waterfall Methodology</h2>
            <p>The waterfall model is a breakdown of project activities into linear sequential phases, where each phase depends on the deliverables of the previous one and corresponds to a specialisation of tasks. The approach is typical for certain areas of engineering design.</p>
              <ul>
                <li>First introduced by Dr. Winston W. Royce in a paper published in 1970, the waterfall model is a software development process.</li>
                <li>The waterfall model emphasizes that a logical progression of steps be taken throughout the software development life cycle (SDLC), much like the cascading steps down an incremental waterfall.</li>
                <li>While the popularity of the waterfall model has waned over recent years in favor of more agile methodologies, the logical nature of the sequential process used in the waterfall method cannot be denied, and it remains a common design process in the industry</li>
                <li>Actually implementing a waterfall model within a new software project is a rather straightforward process, thanks in large part due to the step-by-step nature of the method itself. There are 6 steps which are listed below with a brief description:
                  <ul>
                    <li><b>Requirements:</b> During this initial phase, the potential requirements of the application are methodically analyzed and written down in a specification document that serves as the basis for all future development. The result is typically a requirements document that defines what the application should do, but not how it should do it.</li>
                    <li><b>Analysis:</b> During this second stage, the system is analyzed in order to properly generate the models and business logic that will be used in the application.</li>
                    <li><b>Design:</b> This stage largely covers technical design requirements, such as programming language, data layers, services, etc. A design specification will typically be created that outlines how exactly the business logic covered in analysis will be technically implemented.</li>
                    <li><b>Coding:</b> The actual source code is finally written in this fourth stage, implementing all models, business logic, and service integrations that were specified in the prior stages.</li>
                    <li><b>Testing:</b> During this stage, QA, beta testers, and all other testers systematically discover and report issues within the application that need to be resolved. It is not uncommon for this phase to cause a “necessary repeat” of the previous coding phase, in order for revealed bugs to be properly squashed.</li>
                    <li><b>Operations:</b> Finally, the application is ready for deployment to a live environment. The operations stage entails not just the deployment of the application, but also subsequent support and maintenance that may be required to keep it functional and up-to-date.</li>
                  </ul></li>
                </ul>

                <p>Some benefits of the Waterfall Methodology:</p>
                  <ul>
                    <li><b>Adapts to Shifting Teams:</b> A waterfall method does allow the project as a whole to maintain a more detailed, robust scope and design structure due to all the upfront planning and documentation stages. This is particularly well suited to large teams that may see members come and go throughout the life cycle of the project, allowing the burden of design to be placed on the core documentation and less on any individual team member.</li>
                    <li><b>Forces Structured Organization:</b> The waterfall model forces the project, and even the organization building said project, to be extraordinarily disciplined in its design and structure. Most sizable projects will, by necessity, include detailed procedures to manage every aspect of the project, from design and development to testing and implementation.</li>
                    <li><b>Allows for Early Design Changes:</b> The waterfall approach lends itself well to alterations early in the life cycle. This is great when fleshing out the specification documents in the first couple stages with the development team and clients, as alterations can be made immediately and with minimal effort, since no coding or implementation has actually taken place up to that point.</li>
                    <li><b>Suited for Milestone-Focused Development:</b> With clear, concrete, and well understood stages that everyone on the team can understand and prepare for, it is relatively simple to develop a time line for the entire process and assign particular markers and milestones for each stage and even completion. This isn’t to suggest software development isn’t often rife with delays (since it is), but waterfall is befitting the kind of project that needs deadlines.</li>
                  </ul>
          </section>

          <section>
            <h2>Agile Methodology</h2>
            <p>Every technology organization today seems to practice the agile methodology for software development, or a version of it. Or at least they believe they do. Whether you are new to agile application development or you learned software development decades ago using the waterfall software development methodology, today your work is at least influenced by the agile methodology.</p>
              <ul>
                <li>Back in February of 2001, a small group of seventeen software developers met in the high elevations of Snowbird, Utah to discuss software development methodologies.</li>
                <li>The Agile Values - Within the original Manifesto for Agile Software Development the authors focused on four fundamental, core values that underpin solid software development.
                  <ul>
                    <li><b>Individuals and interactions:</b> Rather than solely emphasizing systems and tools, the focus should be on the people within the team and the interactions they have while working together on the project. For a project to be successful, it should adapt to not just the systems or budget available, but most importantly to the people working on it. If team members are efficient and effective at working together, the end result will be a polished and optimized product.</li>
                    <li><b>Working software:</b> While documentation can certainly be very beneficial during development, it is far better to produce a working product, or even a simple prototype, that illustrates the design goals or the components used throughout the application. This is beneficial not only to other team members working on development, management, and marketing, but especially to clients or testers who would otherwise be forced to rely on a handful of documents and photoshopped illustrations to understand how the application is expected to function.</li>
                    <li><b>Customer collaboration:</b> As with Rapid Application Development, or any other development model born from the roots of the agile model, it is critical that the project be constantly open, willing, and able to respond to customer feedback and behavior. By keeping customers or clients in the loop throughout the entire life cycle, everyone involved will be on the same page and there will not be any surprises at the end or massive rewrites necessary because a module or integration wasn’t clear for all parties involved.</li>
                    <li><b>Responding to change:</b> Perhaps the most critical principle across the entirety of the agile model is the ability for the project to adapt and respond to the ever-changing needs of everyone and everything involved. As development progresses, software technologies will change, the team will shift, clients will hem and haw, and throughout it all, the project should remain malleable and remain capable of adapting along with these needs.</li>
                  </ul>
                </li>
              </ul>

              <p>The Agile Principles - As further outlined in the Manifesto, the agile model is described using twelve key principles, atop which the development life cycle should take place.</p>
                <ol>
                  <li>Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.</li>
                  <li>Welcome changing requirements, even late in development. Agile processes harness change for the customer’s competitive advantage.</li>
                  <li>Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale.</li>
                  <li>Business people and developers must work together daily throughout the project.</li>
                  <li>Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.</li>
                  <li>The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.</li>
                  <li>Working software is the primary measure of progress.</li>
                  <li>Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely.</li>
                  <li>Continuous attention to technical excellence and good design enhances agility.</li>
                  <li>Simplicity–the art of maximizing the amount of work not done–is essential.</li>
                  <li>The best architectures, requirements, and designs emerge from self-organizing teams.</li>
                  <li>At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly.</li>
                </ol>
          </section>

          <section>
            <h2>SCRUM</h2>
            <p>The theory of scrum is focused on being an empirical process: a framework that attempts to gain experienced-based knowledge, then make decisions based on that learned knowledge. To meet that goal, scrum is founded on three core pillars:</p>
              <ul>
                <li><b>Transparency:</b> All relevant aspects of the project must be well-defined and visible to everyone on the team that shares in the responsibility for said aspects.</li>
                <li><b>Inspection:</b> Scrum Artifacts must be frequently inspected, to measure progress toward Sprint Goals (both of which we’ll discuss shortly).</li>
                <li><b>Adaptation:</b> If an inspector decides that an aspect of the project is failing to meet its intended goals, that aspect should be adjusted as quickly as possible.</li>
              </ul>

            <p>The Scrum Guide also lays out the five key scrum values:</p>
              <ul>
                <li><b>Commitment:</b> Team members individually commit to achieving their team goals, each and every Sprint.</li>
                <li><b>Courage:</b> Team members know they have the courage to work through conflict and challenges together so that they can do the right thing.</li>
                <li><b>Focus:</b> Team members focus exclusively on their team goals and the Sprint Backlog; there should be no work done other than through their Backlog.</li>
                <li><b>Openness:</b> Team members and their stakeholders agree to be transparent about their work and any challenges they face.</li>
                <li><b>Respect:</b> Team members respect each other to be technically capable and to work with good intent.</li>
              </ul>

            <p>Scrum Team Roles - There are three primary roles within the whole of the scrum team:</p>
              <ul>
                <li><b>Product Owner:</b> This individual can best be thought of as the project lead or producer, and his or her aim is to maximize the value of the product by ensuring the Development Team produces the best possible work. The Product Owner largely focuses on maintaining the Product Backlog</li>
                <li><b>Development Team:</b> The group of developers that actually produce the work defined in the Product Backlog into a functional and releasable iteration. The Development Team should be self-organizing and fully independent from the Scrum Master.</li>
                <li><b>Scrum Master:</b> Acts as both the referee and coach for the whole team when it comes to the proper use and implementation of scrum practices and processes.</li>
              </ul>

            <p>Day-to-day activities within the scrum framework are all based around particular scrum events. All events are “time-boxed”, meaning they each have a maximum duration. This helps to ensure that the development life cycle remains constantly adaptive and properly Agile.</p>
              <ul>
                <li>The scrum framework defines five types of events:</li>
                  <ul>
                    <li><b>Sprint Planning:</b> During this event, the entire team collaborates to define what the Sprint Goal will be for the upcoming Sprint. This is accomplished by answering two simple questions: 1) What work should be accomplished within the next month? 2) How can that work be completed? The Sprint Planning session should be kept to a maximum of eight hours per month.</li>
                    <li><b>Sprint:</b> The bread and butter of scrum practices, a Sprint is a one-month period in which a potentially releasable iteration is created (commonly referred to as a “Done”). In spite of the name, a Sprint is not anything like “crunch time.” Instead, a Sprint is always active: when one Sprint ends, the next immediately begins.</li>
                    <li><b>Daily Scrum:</b> Every day, the Development Team meets for a maximum of 15 minutes to discuss the planned work for the next day.</li>
                    <li><b>Sprint Review:</b> Following the completion of a Sprint, the Sprint Review is an event with a maximum duration of four hours, in which the entire team discusses the Increment results and makes any necessary changes to the Product Backlog.</li>
                    <li><b>Sprint Retrospective:</b> At a maximum of three hours, the Sprint Retrospective occurs after the Sprint Review, but prior to the next Sprint, and is a meeting for the entire team to decide on potential improvements that can be made general to practices or procedures for the next Sprint.</li>
                  </ul>
              </ul>
          </section>

          <section>
            <h2>CI/CD - Continuous integration and continuous delivery</h2>
            <p>The CI/CD pipeline is one of the best practices for devops teams to implement, for delivering code changes more frequently and reliably. It is also an agile methodology best practice, as it enables software development teams to focus on meeting business requirements, code quality, and security because deployment steps are automated.</p>

            <p>Defined - Continuous integration is a coding philosophy and set of practices that drive development teams to implement small changes and check in code to version control repositories frequently. Because most modern applications require developing code in different platforms and tools, the team needs a mechanism to integrate and validate its changes.</p>

            <div>
              <img src="Images/CICD Example.jpg" alt="">
            </div>

            <p>The steps of the process are as below:</p>
              <ol>
                <li><b>Version Control</b> - This is achieved by using git/github and all developer would submit there code to a branch and once tested is merged into the master branch. This keeps a audit track of the changes while also ensuring the latest code can be retrieved at anytime by a developer</li>
                <li><b>Build</b> - Goes to build phase where it gets compiled. You get all the features of that code from various branches of the repository, which merge them and finally use a compiler to compile it. This whole process is called the build phase.</li>
                <li><b>Testing</b> - Once the build phase is over, then you move on to the testing phase. In this phase, we have various kinds of testing, one of them is the unit test (where you test the chunk/unit of software or for its sanity test).</li>
                <li><b>Deploy</b> - When the test is completed, you move on to the deploy phase, where you deploy it into a staging or a test server. Here, you can view the code or you can view the app in a simulator.</li>
                <li><b>Auto Test</b> - Once the code is deployed successfully, you can run another set of a sanity test. If everything is accepted, then it can be deployed to production.</li>
                <li><b>Deploy To Production</b> - Meanwhile in every step, if there is some error, you can shoot a mail back to the development team so that they can fix them. Then they will push it into the version control system and goes back into the pipeline.
                <br>
                Once again if there is any error reported during testing, again the feedback goes to the dev team where they fix it and the process re-iterates if required.</li>
              </ol>
          </section>

        </main>

        <footer>
          <p>&copy;2020 HTML Basics, Amar's Learning</p>
        </footer>
      </div>
    </body>
</html>